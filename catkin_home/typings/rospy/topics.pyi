"""
This type stub file was generated by pyright.
"""

import select
import logging
import genpy
from rospy.core import *

"""
rospy implementation of topics.

Client API
==========

L{Publisher} and L{Subscriber} are the client API for topics.

Internal Implementation
=======================

Internally, L{_TopicImpl} instances (_PublisherImpl/_SubscriberImpl)
are used to manage actual transport connections.  The L{_TopicManager}
is responsible for tracking the system-wide state of publications and
subscriptions as well as the L{_TopicImpl} instances. More info is below.
 
L{_TopicManager}
================

The L{_TopicManager} does the backend topic bookkeeping for the local
node.  Use L{get_topic_manager()} to access singleton. Actual topic
implementations are done through the
L{_TopicImpl}/L{_PublisherImpl}/L{_SubscriberImpl} hierarchy. Client
code generates instances of type L{Publisher}/L{Subscriber}, which
enable to client to create multiple publishers/subscribers of that
topic that get controlled access to the underlying share connections.

Common parent classes for all rospy topics. The rospy topic autogenerators
create classes that are children of these implementations.
"""
_logger = logging.getLogger('rospy.topics')
Message = genpy.Message
if not hasattr(select, 'EPOLLRDHUP'):
    ...
class Topic(object):
    """Base class of L{Publisher} and L{Subscriber}"""
    def __init__(self, name, data_class, reg_type) -> None:
        """
        @param name: graph resource name of topic, e.g. 'laser'. 
        @type  name: str
        @param data_class: message class for serialization
        @type  data_class: L{Message}
        @param reg_type Registration.PUB or Registration.SUB
        @type  reg_type: str
        @raise ValueError: if parameters are invalid
        """
        ...
    
    def get_num_connections(self):
        """
        get the number of connections to other ROS nodes for this topic. For a Publisher,
        this corresponds to the number of nodes subscribing. For a Subscriber, the number
        of publishers.
        @return: number of connections
        @rtype: int
        """
        ...
    
    def unregister(self):
        """
        unpublish/unsubscribe from topic. Topic instance is no longer
        valid after this call. Additional calls to unregister() have no effect.
        """
        ...
    


class Poller(object):
    """
    select.poll/kqueue abstraction to handle socket failure detection
    on multiple platforms.  NOT thread-safe.
    """
    def __init__(self) -> None:
        ...
    
    def noop(self, *args):
        ...
    
    def noop_iter(self):
        ...
    
    def add_poll(self, fd):
        ...
    
    def remove_poll(self, fd):
        ...
    
    def error_poll_iter(self):
        ...
    
    def add_epoll(self, fd):
        ...
    
    def remove_epoll(self, fd):
        ...
    
    def error_epoll_iter(self):
        ...
    
    def add_kqueue(self, fd):
        ...
    
    def error_kqueue_iter(self):
        ...
    
    def remove_kqueue(self, fd):
        ...
    


class _TopicImpl(object):
    """
    Base class of internal topic implementations. Each topic has a
    singleton _TopicImpl implementation for managing the underlying
    connections.
    """
    def __init__(self, name, data_class) -> None:
        """
        Base constructor
        @param name: graph resource name of topic, e.g. 'laser'. 
        @type  name: str
        @param data_class: message data class 
        @type  data_class: L{Message}
        """
        ...
    
    def __del__(self):
        ...
    
    def close(self):
        """close I/O"""
        ...
    
    def get_num_connections(self):
        ...
    
    def has_connection(self, endpoint_id):
        """
        Query whether or not a connection with the associated \a
        endpoint has been added to this object.
        @param endpoint_id: endpoint ID associated with connection. 
        @type  endpoint_id: str
        """
        ...
    
    def has_connections(self):
        """
        Check to see if this topic is connected to other publishers/subscribers 
        @return: True if topic is connected
        @rtype: bool
        """
        ...
    
    def add_connection(self, c):
        """
        Add a connection to this topic.  If any previous connections
        to same endpoint exist, drop them.
        
        @param c: connection instance
        @type  c: Transport
        @return: True if connection was added, ``bool``
        """
        ...
    
    def check(self):
        ...
    
    def remove_connection(self, c):
        """
        Remove connection from topic.
        @param c: connection instance to remove
        @type  c: Transport
        """
        ...
    
    def get_stats_info(self):
        """
        Get the stats for this topic
        @return: stats for topic in getBusInfo() format::
          Publisher:
          ((connection_id, destination_caller_id, direction, transport, topic_name, connected, connection_info_string)*)
          Subscriber:
          ((connection_id, publisher_xmlrpc_uri, direction, transport, topic_name, connected, connection_info_string)*)
        @rtype: list
        """
        ...
    
    def get_stats(self):
        """Get the stats for this topic (API stub)"""
        ...
    


class Subscriber(Topic):
    """
    Class for registering as a subscriber to a specified topic, where
    the messages are of a given type.
    """
    def __init__(self, name, data_class, callback=..., callback_args=..., queue_size=..., buff_size=..., tcp_nodelay=...) -> None:
        """
        Constructor.

        NOTE: for the queue_size and buff_size
        parameters, rospy does not attempt to do intelligent merging
        between multiple Subscriber instances for the same topic. As
        they share the same underlying transport, multiple Subscribers
        to the same topic can conflict with one another if they set
        these parameters differently.

        @param name: graph resource name of topic, e.g. 'laser'.
        @type  name: str
        @param data_class: data type class to use for messages,
          e.g. std_msgs.msg.String
        @type  data_class: L{Message} class
        @param callback: function to call ( fn(data)) when data is
          received. If callback_args is set, the function must accept
          the callback_args as a second argument, i.e. fn(data,
          callback_args).  NOTE: Additional callbacks can be added using
          add_callback().
        @type  callback: fn(msg, cb_args)
        @param callback_args: additional arguments to pass to the
          callback. This is useful when you wish to reuse the same
          callback for multiple subscriptions.
        @type  callback_args: any
        @param queue_size: maximum number of messages to receive at
          a time. This will generally be 1 or None (infinite,
          default). buff_size should be increased if this parameter
          is set as incoming data still needs to sit in the incoming
          buffer before being discarded. Setting queue_size
          buff_size to a non-default value affects all subscribers to
          this topic in this process.
        @type  queue_size: int
        @param buff_size: incoming message buffer size in bytes. If
          queue_size is set, this should be set to a number greater
          than the queue_size times the average message size. Setting
          buff_size to a non-default value affects all subscribers to
          this topic in this process.
        @type  buff_size: int
        @param tcp_nodelay: if True, request TCP_NODELAY from
          publisher.  Use of this option is not generally recommended
          in most cases as it is better to rely on timestamps in
          message data. Setting tcp_nodelay to True enables TCP_NODELAY
          for all subscribers in the same python process.
        @type  tcp_nodelay: bool
        @raise ROSException: if parameters are invalid
        """
        ...
    
    def unregister(self):
        """
        unpublish/unsubscribe from topic. Topic instance is no longer
        valid after this call. Additional calls to unregister() have no effect.
        """
        ...
    


class _SubscriberImpl(_TopicImpl):
    """
    Underyling L{_TopicImpl} implementation for subscriptions.
    """
    def __init__(self, name, data_class) -> None:
        """
        ctor.
        @param name: graph resource name of topic, e.g. 'laser'.
        @type  name: str
        @param data_class: Message data class
        @type  data_class: L{Message} class
        """
        ...
    
    def close(self):
        """close I/O and release resources"""
        ...
    
    def set_tcp_nodelay(self, tcp_nodelay):
        """
        Set the value of TCP_NODELAY, which causes the Nagle algorithm
        to be disabled for future topic connections, if the publisher
        supports it.
        """
        ...
    
    def set_queue_size(self, queue_size):
        """
        Set the receive queue size. If more than queue_size messages
        are waiting to be deserialized, they are discarded.
        
        @param queue_size int: incoming queue size. Must be positive integer or None.
        @type  queue_size: int
        """
        ...
    
    def set_buff_size(self, buff_size):
        """
        Set the receive buffer size. The exact meaning of this is
        transport dependent.
        @param buff_size: receive buffer size
        @type  buff_size: int
        """
        ...
    
    def get_stats(self):
        """
        Get the stats for this topic subscriber
        @return: stats for topic in getBusStats() publisher format::
           (topicName, connStats)
        where connStats is::
           [connectionId, bytesReceived, numSent, dropEstimate, connected]*
        @rtype: list
        """
        ...
    
    def add_callback(self, cb, cb_args):
        """
        Register a callback to be invoked whenever a new message is received
        @param cb: callback function to invoke with message data
          instance, i.e. fn(data). If callback args is set, they will
          be passed in as the second argument.
        @type  cb: fn(msg, cb_args)
        @param cb_cargs: additional arguments to pass to callback
        @type  cb_cargs: Any
        """
        ...
    
    def remove_callback(self, cb, cb_args):
        """
        Unregister a message callback.
        @param cb: callback function
        @type  cb: fn(msg, cb_args)
        @param cb_cargs: additional arguments associated with callback
        @type  cb_cargs: Any
        @raise KeyError: if no matching callback
        """
        ...
    
    def receive_callback(self, msgs, connection):
        """
        Called by underlying connection transport for each new message received
        @param msgs: message data
        @type msgs: [L{Message}]
        """
        ...
    


class SubscribeListener(object):
    """
    Callback API to receive notifications when new subscribers
    connect and disconnect.
    """
    def peer_subscribe(self, topic_name, topic_publish, peer_publish):
        """
        callback when a peer has subscribed from a topic
        @param topic_name: topic name. NOTE: topic name will be resolved/remapped
        @type  topic_name: str
        @param topic_publish: method to publish message data to all subscribers
        @type  topic_publish: fn(data)
        @param peer_publish: method to publish message data to
          new subscriber.  NOTE: behavior for the latter is
          transport-dependent as some transports may be broadcast only.
        @type  peer_publish: fn(data)
        """
        ...
    
    def peer_unsubscribe(self, topic_name, num_peers):
        """
        callback when a peer has unsubscribed from a topic
        @param topic_name: topic name. NOTE: topic name will be resolved/remapped
        @type  topic_name: str
        @param num_peers: number of remaining peers subscribed to topic
        @type  num_peers: int
        """
        ...
    


class Publisher(Topic):
    """
    Class for registering as a publisher of a ROS topic.
    """
    def __init__(self, name, data_class, subscriber_listener=..., tcp_nodelay=..., latch=..., headers=..., queue_size=...) -> None:
        """
        Constructor
        @param name: resource name of topic, e.g. 'laser'. 
        @type  name: str
        @param data_class: message class for serialization
        @type  data_class: L{Message} class
        @param subscriber_listener: listener for
          subscription events. May be None.
        @type  subscriber_listener: L{SubscribeListener}
        @param tcp_nodelay: If True, sets TCP_NODELAY on
          publisher's socket (disables Nagle algorithm). This results
          in lower latency publishing at the cost of efficiency.
        @type  tcp_nodelay: bool
        @param latch: If True, the last message published is
        'latched', meaning that any future subscribers will be sent
        that message immediately upon connection.
        @type  latch: bool
        @param headers: If not None, a dictionary with additional header
        key-values being used for future connections.
        @type  headers: dict
        @param queue_size: The queue size used for asynchronously
        publishing messages from different threads.  A size of zero
        means an infinite queue, which can be dangerous.  When the
        keyword is not being used or when None is passed all
        publishing will happen synchronously and a warning message
        will be printed.
        @type  queue_size: int
        @raise ROSException: if parameters are invalid     
        """
        ...
    
    def publish(self, *args, **kwds) -> None:
        """
        Publish message data object to this topic. 
        Publish can either be called with the message instance to
        publish or with the constructor args for a new Message
        instance, i.e.::
          pub.publish(message_instance)
          pub.publish(message_field_1, message_field_2...)            
          pub.publish(message_field_1='foo', message_field_2='bar')
    
        @param args : L{Message} instance, message arguments, or no args if keyword arguments are used
        @param kwds : Message keyword arguments. If kwds are used, args must be unset
        @raise ROSException: If rospy node has not been initialized
        @raise ROSSerializationException: If unable to serialize
        message. This is usually a type error with one of the fields.
        """
        ...
    


class _PublisherImpl(_TopicImpl):
    """
    Underyling L{_TopicImpl} implementation for publishers.
    """
    def __init__(self, name, data_class) -> None:
        """
        @param name: name of topic, e.g. 'laser'. 
        @type  name: str
        @param data_class: Message data class    
        @type  data_class: L{Message} class
        """
        ...
    
    def close(self):
        """close I/O and release resources"""
        ...
    
    def add_headers(self, headers):
        """
        Add connection headers to this Topic for future connections.
        @param headers: key/values will be added to current connection
        header set, overriding any existing keys if they conflict.
        @type  headers: dict
        """
        ...
    
    def enable_latch(self):
        """
        Enable publish() latch. The latch contains the last published
        message and is sent to any new subscribers.
        """
        ...
    
    def set_queue_size(self, queue_size):
        ...
    
    def get_stats(self):
        """
        Get the stats for this topic publisher
        @return: stats for topic in getBusStats() publisher format::
          [topicName, messageDataBytes, connStats],
        where connStats is::
          [id, bytes, numMessages, connected]*
        @rtype: list
        """
        ...
    
    def add_subscriber_listener(self, l):
        """
        Add a L{SubscribeListener} for subscribe events.
        @param l: listener instance
        @type  l: L{SubscribeListener}
        """
        ...
    
    def acquire(self):
        """lock for thread-safe publishing to this transport"""
        ...
    
    def release(self):
        """lock for thread-safe publishing to this transport"""
        ...
    
    def add_connection(self, c):
        """
        Add a connection to this topic. This must be a PubTransport. If
        the latch is enabled, c will be sent a the value of the
        latch.
        @param c: connection instance
        @type  c: L{Transport}
        @return: True if connection was added
        @rtype: bool
        """
        ...
    
    def remove_connection(self, c):
        """
        Remove existing connection from this topic.
        @param c: connection instance to remove
        @type  c: L{Transport}
        """
        ...
    
    def publish(self, message, connection_override=...):
        """
        Publish the data to the topic. If the topic has no subscribers,
        the method will return without any affect. Access to publish()
        should be locked using acquire() and release() in order to
        ensure proper message publish ordering.

        @param message: message data instance to publish
        @type  message: L{Message}
        @param connection_override: publish to this connection instead of all
        @type  connection_override: L{Transport}
        @return: True if the data was published, False otherwise.
        @rtype: bool
        @raise genpy.SerializationError: if L{Message} instance is unable to serialize itself
        @raise rospy.ROSException: if topic has been closed or was closed during publish()
        """
        ...
    


class _TopicManager(object):
    """
    Tracks Topic objects
    See L{get_topic_manager()} for singleton access
    """
    def __init__(self) -> None:
        """ctor."""
        ...
    
    def get_pub_sub_info(self):
        """
        get topic publisher and subscriber connection info for getBusInfo() api
        @return: [bus info stats]
          See getBusInfo() API for more data structure details.
        @rtype: list
        """
        ...
    
    def get_pub_sub_stats(self):
        """
        get topic publisher and subscriber stats for getBusStats() api
        @return: [publisherStats, subscriberStats].
          See getBusStats() API for more data structure details.
        @rtype: list
        """
        ...
    
    def close_all(self):
        """
        Close all registered publication and subscriptions. Manager is
        no longer usable after close.
        """
        ...
    
    def check_all(self):
        """
        Check all registered publication and subscriptions.
        """
        ...
    
    def get_impl(self, reg_type, resolved_name):
        """
        Get the L{_TopicImpl} for the specified topic. This is mainly for
        testing purposes. Unlike acquire_impl, it does not alter the
        ref count.
        @param resolved_name: resolved topic name
        @type  resolved_name: str
        @param reg_type: L{rospy.registration.Registration.PUB} or L{rospy.registration.Registration.SUB}
        @type  reg_type: str
        """
        ...
    
    def acquire_impl(self, reg_type, resolved_name, data_class):
        """
        Acquire a L{_TopicImpl} for the specified topic (create one if it
        doesn't exist).  Every L{Topic} instance has a _TopicImpl that
        actually controls the topic resources so that multiple Topic
        instances use the same underlying connections. 'Acquiring' a
        topic implementation marks that another Topic instance is
        using the TopicImpl.
        
        @param resolved_name: resolved topic name
        @type  resolved_name: str
        
        @param reg_type: L{rospy.registration.Registration.PUB} or L{rospy.registration.Registration.SUB}
        @type  reg_type: str
        
        @param data_class: message class for topic
        @type  data_class: L{Message} class
        """
        ...
    
    def release_impl(self, reg_type, resolved_name):
        """
        Release a L_{TopicImpl} for the specified topic.

        Every L{Topic} instance has a _TopicImpl that actually
        controls the topic resources so that multiple Topic instances
        use the same underlying connections. 'Acquiring' a topic
        implementation marks that another Topic instance is using the
        TopicImpl.

        @param resolved_name: resolved topic name
        @type  resolved_name: str
        @param reg_type: L{rospy.registration.Registration.PUB} or L{rospy.registration.Registration.SUB}
        @type  reg_type: str
        """
        ...
    
    def get_publisher_impl(self, resolved_name):
        """
        @param resolved_name: resolved topic name
        @type  resolved_name: str
        @return: list of L{_PublisherImpl}s
        @rtype: [L{_PublisherImpl}]
        """
        ...
    
    def get_subscriber_impl(self, resolved_name):
        """
        @param resolved_name: topic name
        @type  resolved_name: str
        @return: subscriber for the specified topic. 
        @rtype: L{_SubscriberImpl}
        """
        ...
    
    def has_subscription(self, resolved_name):
        """
        @param resolved_name: resolved topic name
        @type  resolved_name: str
        @return: True if manager has subscription for specified topic
        @rtype: bool
        """
        ...
    
    def has_publication(self, resolved_name):
        """
        @param resolved_name: resolved topic name
        @type  resolved_name: str
        @return: True if manager has publication for specified topic
        @rtype:  bool
        """
        ...
    
    def get_topics(self):
        """
        @return: list of topic names this node subscribes to/publishes
        @rtype: [str]
        """
        ...
    
    def get_subscriptions(self):
        ...
    
    def get_publications(self):
        ...
    



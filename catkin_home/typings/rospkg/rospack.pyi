"""
This type stub file was generated by pyright.
"""

from threading import Lock

_cache_lock = Lock()
def list_by_path(manifest_name, path, cache):
    """
    List ROS stacks or packages within the specified path.

    The cache will be updated with the resource->path
    mappings. list_by_path() does NOT returned cached results
    -- it only updates the cache.

    :param manifest_name: MANIFEST_FILE or STACK_FILE, ``str``
    :param path: path to list resources in, ``str``
    :param cache: path cache to update. Maps resource name to directory path, ``{str: str}``
    :returns: complete list of resources in ROS environment, ``[str]``
    """
    ...

class ManifestManager(object):
    """
    Base class implementation for :class:`RosPack` and
    :class:`RosStack`.  This class indexes resources on paths with
    where manifests denote the precense of the resource.  NOTE: for
    performance reasons, instances cache information and will not
    reflect changes made on disk or to environment configuration.
    """
    def __init__(self, manifest_name, ros_paths=...) -> None:
        """
        ctor. subclasses are expected to use *manifest_name*
        to customize behavior of ManifestManager.

        :param manifest_name: MANIFEST_FILE or STACK_FILE
        :param ros_paths: Ordered list of paths to search for
          resources. If `None` (default), use environment ROS path.
        """
        ...
    
    @classmethod
    def get_instance(cls, ros_paths=...):
        """
        Reuse an existing instance for the specified ros_paths instead of creating a new one.
        Only works for subclasses, as the ManifestManager itself expects two args for the ctor.

        :param ros_paths: Ordered list of paths to search for
          resources. If `None` (default), use environment ROS path.
        """
        ...
    
    def get_ros_paths(self):
        ...
    
    ros_paths = ...
    def get_manifest(self, name):
        """
        :raises: :exc:`InvalidManifest`
        """
        ...
    
    def list(self):
        """
        List resources.

        :returns: complete list of package names in ROS environment, ``[str]``
        """
        ...
    
    def get_path(self, name):
        """
        :param name: package name, ``str``
        :returns: filesystem path of package
        :raises: :exc:`ResourceNotFound`
        """
        ...
    
    def get_depends(self, name, implicit=...):
        """
        Get dependencies of a resource.  If implicit is ``True``, this
        includes implicit (recursive) dependencies.

        :param name: resource name, ``str``
        :param implicit: include implicit (recursive) dependencies, ``bool``

        :returns: list of names of dependencies, ``[str]``
        :raises: :exc:`InvalidManifest` If resource or any of its
          dependencies have an invalid manifest.
        """
        ...
    
    def get_depends_on(self, name, implicit=...):
        """
        Get resources that depend on a resource.  If implicit is ``True``, this
        includes implicit (recursive) dependency relationships.

        NOTE: this does *not* raise :exc:`rospkg.InvalidManifest` if
        there are invalid manifests found.

        :param name: resource name, ``str``
        :param implicit: include implicit (recursive) dependencies, ``bool``

        :returns: list of names of dependencies, ``[str]``
        """
        ...
    
    def get_custom_cache(self, key, default=...):
        ...
    
    def set_custom_cache(self, key, value):
        ...
    


class RosPack(ManifestManager):
    """
    Utility class for querying properties about ROS packages. This
    should be used when querying properties about multiple
    packages.

    NOTE 1: for performance reasons, RosPack caches information about
    packages.

    NOTE 2: RosPack is not thread-safe.

    Example::
      from rospkg import RosPack
      rp = RosPack()
      packages = rp.list()
      path = rp.get_path('rospy')
      depends = rp.get_depends('roscpp')
      direct_depends = rp.get_depends('roscpp', implicit=False)
    """
    def __init__(self, ros_paths=...) -> None:
        """
        :param ros_paths: Ordered list of paths to search for
          resources. If `None` (default), use environment ROS path.
        """
        ...
    
    def get_rosdeps(self, package, implicit=...):
        """
        Collect rosdeps of specified package into a dictionary.

        :param package: package name, ``str``
        :param implicit: include implicit (recursive) rosdeps, ``bool``

        :returns: list of rosdep names, ``[str]``
        """
        ...
    
    def stack_of(self, package):
        """
        :param package: package name, ``str``
        :returns: name of stack that package is in, or None if package is not part of a stack, ``str``
        :raises: :exc:`ResourceNotFound` If package cannot be located
        """
        ...
    


class RosStack(ManifestManager):
    """
    Utility class for querying properties about ROS stacks. This
    should be used when querying properties about multiple
    stacks.

    NOTE 1: for performance reasons, RosStack caches information about
    stacks.

    NOTE 2: RosStack is not thread-safe.
    """
    def __init__(self, ros_paths=...) -> None:
        """
        :param ros_paths: Ordered list of paths to search for
          resources. If `None` (default), use environment ROS path.
        """
        ...
    
    def packages_of(self, stack):
        """
        :returns: name of packages that are part of stack, ``[str]``
        :raises: :exc:`ResourceNotFound` If stack cannot be located
        """
        ...
    
    def get_stack_version(self, stack):
        """
        :param env: override environment variables, ``{str: str}``
        :returns: version number of stack, or None if stack is unversioned, ``str``
        """
        ...
    


def expand_to_packages(names, rospack, rosstack):
    """
    Expand names into a list of packages. Names can either be of packages or stacks.

    :param names: names of stacks or packages, ``[str]``
    :returns: ([packages], [not_found]). Returns two lists. The first
      is of packages names. The second is a list of names for which no
      matching stack or package was found. Lists may have
      duplicates. ``([str], [str])``
    """
    ...

def get_stack_version_by_dir(stack_dir):
    """
    Get stack version where stack_dir points to root directory of stack.

    :param env: override environment variables, ``{str: str}``

    :returns: version number of stack, or None if stack is unversioned, ``str``
    :raises: :exc:`IOError`
    :raises: :exc:`InvalidStack`
    """
    ...

def get_package_name(path):
    """
    Get the name of the ROS package that contains *path*. This is
    determined by finding the nearest parent ``manifest.xml`` file.
    This routine may not traverse package setups that rely on internal
    symlinks within the package itself.

    :param path: filesystem path
    :return: Package name or ``None`` if package cannot be found, ``str``
    """
    ...

